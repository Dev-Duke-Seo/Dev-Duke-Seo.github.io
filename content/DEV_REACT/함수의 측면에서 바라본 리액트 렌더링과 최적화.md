---
title: "리액트 성능 최적화: 결국 화면에 나오는 것은 함수의 리턴 값이다"
description: 리렌더링의 진짜 목적 이해하기
release: true
date: 2025-04-16
tags:
  - react
  - 최적화
  - 렌더링
---

리액트를 다룰 때, "렌더링"은 항상 빠질 수 없는 주체다.
태생이 DOM을 다루기 위한 라이브러리기 때문일 것이다.

렌더링을 최적하기위해 머리를 싸매는 시간이 상당히 긴데
이 때 종종 간과하게되는 사실이,
바로 **"결국 브라우저의 렌더링되는 것은 컴포넌트의 리턴값"** 이라는 사실이다.  

복잡한 최적화 기법에 집중하기 전에, 우리가 신경 써야 할 것은  
**컴포넌트가 실제로 화면에 렌더링되는 방식과 그 변화**다.  
이번 글에서는 리액트를 다루며 정리된 리렌더링과 최적화에 대한 내용을 다루어보았다.

---

# 리렌더링의 진짜 목적 이해하기

리액트를 사용하다 보면 성능 최적화에 대한 이야기를 자주 접하게 된다. 특히 `React.memo`, `useMemo`, `useCallback` 같은 도구들을 통해 불필요한 리렌더링을 막아야 한다는 조언을 많이 듣는다. 

**하지만 이런 최적화의 본질은 단순히 리렌더링 횟수를 줄이는 것이 아니라는 점을 이해하는 것이 중요하다.**

## 리렌더링과 화면 업데이트의 관계

리액트의 리렌더링은 컴포넌트 함수가 다시 실행되는 것을 의미한다. 그러나 이 리렌더링이 항상 DOM 업데이트로 이어지는 것은 아니다. 리액트는 가상 DOM을 통해 실제로 변경된 부분만 실제 DOM에 적용하는 방식으로 작동한다.

jsx

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  // 리렌더링되더라도 리턴값이 같으면 DOM은 변경되지 않는다
  return <div className="counter">{count}</div>;
}
```

위 예제에서 
1. `count` 값이 변경되지 않는 한, 컴포넌트가 여러 번 리렌더링(함수의 실행)되더라도 
2. 리턴값의 변화가 없다. = 실제 DOM 업데이트는 발생하지 않는다. 

이것이 리액트가 브라우저 렌더링을 관리하는 핵심이다.

## 최적화의 진정한 목적

성능 최적화의 진정한 목적은 단순히 리렌더링 횟수를 줄이는 것이 아니라, **필요할 때만 리렌더링이 일어나도록 관리하는 것**이다. 불필요한 계산과 비교 작업을 줄여 애플리케이션의 반응성을 높이는 것이 중요하다.

### 좋은 최적화와 불필요한 최적화

```jsx
// 불필요한 최적화의 예
const MemoizedComponent = React.memo(function Component(props) {
  // 이 컴포넌트가 자주 리렌더링되더라도
  // 리턴값이 같다면 DOM 업데이트는 발생하지 않는다
  return <div>Hello, World!</div>;
});
```

위 예시에서 `Component`는 props가 변경되지 않는 한 항상 같은 결과를 반환한다. 이런 경우 `React.memo`로 감싸는 것이 실제 성능 향상에 기여하는지 의문이다. 오히려 `memo`에 의한 얕은 비교 연산이 추가되어 미세한 성능 저하가 발생할 수 있다.

## 효과적인 최적화 전략

1. **상태 관리 구조화하기**: 전역 상태와 지역 상태를 적절히 분리하여 변경이 필요한 부분만 리렌더링되도록 한다.
2. **불변성 유지하기**: 객체나 배열을 직접 수정하지 않고 새로운 참조를 생성하여 리액트가 변경을 감지할 수 있게 한다.
3. **컴포넌트 분리하기**: 상태 변경에 영향을 받는 부분과 그렇지 않은 부분을 분리하여 필요한 부분만 리렌더링되도록 한다.

jsx

```jsx
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <Counter count={count} setCount={setCount} />
      <ExpensiveComponent /> {/* count가 변해도 이 컴포넌트는 리렌더링될 필요 없음 */}
    </div>
  );
}

// 비용이 많이 드는 컴포넌트는 분리 후 메모이제이션
const ExpensiveComponent = React.memo(function() {
  // 복잡한 계산 또는 많은 하위 컴포넌트를 포함
  return <div>/* 복잡한 UI */</div>;
});
```

## 최적화에 대한 접근법

리액트에서 성능 최적화의 핵심은 리렌더링 자체를 막는 것이 아니라, 필요할 때만 리렌더링이 일어나도록 하는 것이다. 화면에 변화가 필요할 때만 컴포넌트가 리렌더링되도록 설계함으로써 애플리케이션의 반응성과 효율성을 높일 수 있다. 리턴값의 변화와 실제 DOM 업데이트의 관계를 이해하는 것이 성능 최적화의 출발점이라 할 수 있다.

리액트의 선언적인 패러다임을 따라, "언제 화면이 바뀌어야 하는가"에 초점을 맞추는 것이 효과적인 최적화의 기본인 것 같다.